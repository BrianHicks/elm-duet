port module Main.Ports exposing (..)

{-| Warning: this file is automatically generated. Don't edit by hand!
-}

import Dict exposing (Dict)
import Json.Decode
import Json.Decode.Pipeline
import Json.Encode


type alias Close =
    { code : Int
    , reason : String
    , wasClean : Bool
    }


closeDecoder : Json.Decode.Decoder Close
closeDecoder =
    Json.Decode.succeed Close
        |> Json.Decode.Pipeline.required "code" Json.Decode.int
        |> Json.Decode.Pipeline.required "reason" Json.Decode.string
        |> Json.Decode.Pipeline.required "wasClean" Json.Decode.bool


encodeClose : Close -> Json.Encode.Value
encodeClose close =
    Json.Encode.object
        [ ( "code", Json.Encode.int close.code )
        , ( "reason", Json.Encode.string close.reason )
        , ( "wasClean", Json.Encode.bool close.wasClean )
        , ( "tag", Json.Encode.string "close" )
        ]


type alias TagError =
    {}


tagErrorDecoder : Json.Decode.Decoder TagError
tagErrorDecoder =
    Json.Decode.succeed TagError


encodeTagError : TagError -> Json.Encode.Value
encodeTagError tagError =
    Json.Encode.object
        [ ( "tag", Json.Encode.string "error" )
        ]


type alias Message =
    { data : String
    , origin : String
    }


messageDecoder : Json.Decode.Decoder Message
messageDecoder =
    Json.Decode.succeed Message
        |> Json.Decode.Pipeline.required "data" Json.Decode.string
        |> Json.Decode.Pipeline.required "origin" Json.Decode.string


encodeMessage : Message -> Json.Encode.Value
encodeMessage message =
    Json.Encode.object
        [ ( "data", Json.Encode.string message.data )
        , ( "origin", Json.Encode.string message.origin )
        , ( "tag", Json.Encode.string "message" )
        ]


type alias TagOpen =
    {}


tagOpenDecoder : Json.Decode.Decoder TagOpen
tagOpenDecoder =
    Json.Decode.succeed TagOpen


encodeTagOpen : TagOpen -> Json.Encode.Value
encodeTagOpen tagOpen =
    Json.Encode.object
        [ ( "tag", Json.Encode.string "open" )
        ]


type FromWorld
    = Close Close
    | Error TagError
    | Message Message
    | Open TagOpen


fromWorldDecoder : Json.Decode.Decoder FromWorld
fromWorldDecoder =
    Json.Decode.andThen
        (\tag ->
            case tag of
                "close" ->
                    Json.Decode.map Close closeDecoder

                "error" ->
                    Json.Decode.map Error tagErrorDecoder

                "message" ->
                    Json.Decode.map Message messageDecoder

                "open" ->
                    Json.Decode.map Open tagOpenDecoder
        )
        (Json.Decode.field "tag" Json.Decode.string)


encodeFromWorld : FromWorld -> Json.Encode.Value
encodeFromWorld fromWorld =
    case fromWorld of
        Close close ->
            encodeClose close

        Error error ->
            encodeTagError error

        Message message ->
            encodeMessage message

        Open open ->
            encodeTagOpen open


type alias Close =
    { code : Int
    , reason : String
    }


closeDecoder : Json.Decode.Decoder Close
closeDecoder =
    Json.Decode.succeed Close
        |> Json.Decode.Pipeline.required "code" Json.Decode.int
        |> Json.Decode.Pipeline.required "reason" Json.Decode.string


encodeClose : Close -> Json.Encode.Value
encodeClose close =
    Json.Encode.object
        [ ( "code", Json.Encode.int close.code )
        , ( "reason", Json.Encode.string close.reason )
        , ( "tag", Json.Encode.string "close" )
        ]


type alias Connect =
    { protocols : Maybe (List String)
    , url : String
    }


connectDecoder : Json.Decode.Decoder Connect
connectDecoder =
    Json.Decode.succeed Connect
        |> Json.Decode.Pipeline.optional "protocols" (Json.Decode.nullable (Json.Decode.list Json.Decode.string)) Nothing
        |> Json.Decode.Pipeline.required "url" Json.Decode.string


encodeConnect : Connect -> Json.Encode.Value
encodeConnect connect =
    List.filterMap identity
        [ Maybe.map (\protocols -> Json.Encode.list (\value -> Json.Encode.string value) protocols) connect.protocols
        , Just ( "url", Json.Encode.string connect.url )
        , Just ( "tag", Json.Encode.string "connect" )
        ]
        |> Json.Encode.object


type alias Send =
    { message : String
    }


sendDecoder : Json.Decode.Decoder Send
sendDecoder =
    Json.Decode.succeed Send
        |> Json.Decode.Pipeline.required "message" Json.Decode.string


encodeSend : Send -> Json.Encode.Value
encodeSend send =
    Json.Encode.object
        [ ( "message", Json.Encode.string send.message )
        , ( "tag", Json.Encode.string "send" )
        ]


type ToWorld
    = Close Close
    | Connect Connect
    | Send Send


toWorldDecoder : Json.Decode.Decoder ToWorld
toWorldDecoder =
    Json.Decode.andThen
        (\tag ->
            case tag of
                "close" ->
                    Json.Decode.map Close closeDecoder

                "connect" ->
                    Json.Decode.map Connect connectDecoder

                "send" ->
                    Json.Decode.map Send sendDecoder
        )
        (Json.Decode.field "tag" Json.Decode.string)


encodeToWorld : ToWorld -> Json.Encode.Value
encodeToWorld toWorld =
    case toWorld of
        Close close ->
            encodeClose close

        Connect connect ->
            encodeConnect connect

        Send send ->
            encodeSend send


port fromWorld : (Json.Decode.Value -> msg) -> Sub msg


subscribeToFromWorld : (Result Json.Decode.Error FromWorld -> msg) -> Sub msg
subscribeToFromWorld toMsg =
    fromWorld (\value -> toMsg (Json.Decode.decodeValue value fromWorldDecoder))


port toWorld : Json.Decode.Value -> Cmd msg


sendToWorld : ToWorld -> Cmd msg
sendToWorld value =
    toWorld (encodeToWorld value)
