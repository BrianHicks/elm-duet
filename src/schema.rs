use crate::typescript::TSType;
use color_eyre::Result;
use eyre::WrapErr;
use serde::Deserialize;
use std::collections::BTreeMap;
use std::path::Path;

#[derive(Debug, Deserialize)]
pub struct Schema {
    #[serde(default)]
    pub definitions: BTreeMap<String, jtd::SerdeSchema>,
    pub modules: BTreeMap<String, Module>,
}

#[derive(Debug, Deserialize)]
pub struct Module {
    pub flags: Option<jtd::SerdeSchema>,
}

impl Schema {
    pub fn from_fs(path: &Path) -> Result<Schema> {
        let bytes = std::fs::read(path).wrap_err_with(|| format!("could not read {path:?}"))?;
        serde_json::from_slice(&bytes)
            .wrap_err_with(|| format!("could not read schema from {path:?}"))
    }

    pub fn flags_to_ts(&self) -> Result<String> {
        let mut buffer =
            String::from("// Warning: this file is automatically generated. Don't edit by hand!\n");

        // let mut classes = Vec::with_capacity(self.modules.len());

        for (module_name, module) in &self.modules {
            let flags: TSType;
            if let Some(flags_serde) = &module.flags {
                flags = TSType::from_schema(
                    jtd::Schema::from_serde_schema(flags_serde.clone()).wrap_err_with(|| {
                        format!(
                            "could not interpret JTD schema for flags in the {} module",
                            module_name
                        )
                    })?,
                )
                .into_typedecl("Flags".to_string());
            } else {
                flags = TSType::new_ref("Record<string, never>".to_string());
            }

            let app = TSType::new_class(
                "App".to_string(),
                Vec::from([
                    TSType::new_ref("Flags".to_string()).into_init(),
                    TSType::new_ref("Ports".to_string()).into_class_property("flags".to_string()),
                ]),
            );

            let ports = TSType::new_object(BTreeMap::new()).into_typedecl("Ports".to_string());

            buffer.push_str(&flags.to_source());
            buffer.push_str("\n\n");
            buffer.push_str(&ports.to_source());
            buffer.push_str("\n\n");
            buffer.push_str(&app.to_source());
            buffer.push('\n');
        }

        // if let Some(flags_serde) = &self.flags {
        //     let flags = jtd::Schema::from_serde_schema(flags_serde.clone())
        //         .wrap_err("could not interpret JTD schema for flags")?;
        //
        //     buffer.push('\n');
        //     buffer.push_str(
        //         &TSType::from_schema(flags)
        //             .into_typedecl("Flags".to_string())
        //             .to_source(),
        //     );
        //
        //     let init = TSType::new_method(
        //         true,
        //         "init".to_string(),
        //         TSType::new_ref("Flags".to_string()).into_init(),
        //     );
        //
        //     let class = TSType::new_class("App".to_string(), Vec::from([init]));
        //
        //     let namespace = TSType::new_namespace("Elm".to_string(), Vec::from([class]));
        //
        //     buffer.push_str("\n\n");
        //     buffer.push_str(&namespace.to_source());
        // }

        Ok(buffer)
    }
}
